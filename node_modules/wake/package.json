{
  "name": "wake",
  "description": "A build tool for web stuff",
  "homepage": "http://github.com/jcoglan/wake",
  "author": {
    "name": "James Coglan",
    "email": "jcoglan@gmail.com",
    "url": "http://jcoglan.com/"
  },
  "keywords": [
    "build"
  ],
  "license": "MIT",
  "version": "0.3.0",
  "engines": {
    "node": ">=0.4.0"
  },
  "main": "./lib/wake",
  "bin": {
    "wake": "./bin/wake"
  },
  "preferGlobal": true,
  "dependencies": {
    "clean-css": ">=1.0.0",
    "csso": ">=1.3.0",
    "ejs": "",
    "glob": "",
    "mime": "",
    "mkdirp": "",
    "nopt": "",
    "uglify-js": ">=2.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jcoglan/wake.git"
  },
  "bugs": {
    "url": "http://github.com/jcoglan/wake/issues"
  },
  "readme": "# wake\n\n`wake` (short for 'web make') is a build tool for website assets. It aims to fix\nthe problems caused by other asset toolchains that conflate several concerns\nrelated to deploying static assets:\n\n* Compiling languages like CoffeeScript and Sass to JavaScript and CSS\n* Optimising JavaScript and CSS for fast download times in production\n* Generating links from HTML to JavaScript, CSS and image files\n\n`wake` *only* implements the second part: it optimises JavaScript, CSS and\nbinary files for production. It is configurable to allow for different use\ncases; I have different concerns when working on an open-source library and when\nworking on an application, and `wake` supports both these use cases. Its default\nsettings are tailored to application deployment.\n\nBecause it only implements the optimisation phase, `wake` is not coupled to any\nweb framework. You can use it in any project, and it generates enough metadata\nfiles that an application can easily find out which files it should generate\nlinks to.\n\nIf you want to compile other languages to JS/CSS, or use a dependency resolver\nlike Browserify, that can be done as a separate step using Make (or one of its\nclones), or by running tasks on file changes using Guard. After this compilation\nstep you can run `wake` on the resulting files to optimise them.\n\nHere's a few of the things `wake` can do with your files:\n\n* Concatenate and minify JavaScript and CSS files\n* Generate optimised files with a content hash in the filename\n* Generate source maps for JavaScript with correct relative path references\n* Resolve and inline CSS files referenced by `@import` statements\n* Rewrite CSS `url()` paths so the optimised CSS references the same files as\n  the source code\n* Inline files referenced by `url()` expressions as data URIs\n\n\n## Installation\n\n```\n$ npm install -g wake\n```\n\n\n## Usage\n\n`wake` is a command-line program; if you installed it globally then type `wake`\nto run it, or if you installed it inside your project then run\n`./node_modules/.bin/wake`.\n\n`wake` is configured using data stored in your project's `package.json` file.\nIts config has three sections: `javascript`, `css` and `binary`. Each section\nhas a `sourceDirectory`, which is the directory containing all the source files,\nand a `targetDirectory`, which is where the optimised files are written to.\n\nThe `css` group also requires a `sourceRoot` setting, which tells `wake` where\nto resolve absolute paths in `url()` expressions when it is inlining `@import`\nstatements and rewriting path references.\n\nThe only other required field is `targets`, which lists the name of each\noptimised file and the names of the source files it should contain.\n\n```js\n// package.json\n\n{\n  \"name\":     \"my-project\",\n  \"version\":  \"0.0.0\",\n\n  \"devDependencies\": {\n    \"wake\": \">=0.2.0\"\n  },\n\n  \"wake\": {\n    \"javascript\": {\n      \"sourceDirectory\": \"public/javascripts\",\n      \"targetDirectory\": \"public/assets\",\n      \"targets\": {\n        \"scripts.js\": [\"foo.js\", \"bar.js\"]\n      }\n    },\n    \"css\": {\n      \"sourceDirectory\": \"public/stylesheets\",\n      \"targetDirectory\": \"public/assets\",\n      \"sourceRoot\":      \"public\",\n      \"targets\": {\n        \"styles.css\": [\"navigation.css\", \"footer.css\"]\n      }\n    },\n    \"binary\": {\n      \"sourceDirectory\": \"public/images\",\n      \"targetDirectory\": \"public/assets\",\n      \"targets\": {\n        \"logo.png\": \"logo.png\"\n      }\n    }\n  }\n}\n```\n\nThis configuration takes the following project tree:\n\n```\n.\n├── package.json\n└── public\n    ├── images\n    │   └── logo.png\n    ├── javascripts\n    │   ├── bar.js\n    │   └── foo.js\n    └── stylesheets\n        ├── footer.css\n        └── navigation.css\n```\n\nand generates the following files when you run `wake`:\n\n```\n.\n├── .wake.json\n└── public\n    └── assets\n        ├── .manifest.json\n        ├── logo.png\n        ├── logo-2fa8d38.png\n        ├── scripts.js\n        ├── scripts-bb210c6.js\n        ├── scripts.js.map\n        ├── scripts-300b304.js.map\n        ├── styles.css\n        └── styles-5a2ceb1.css\n```\n\n\n### Generated files\n\nTwo copies of each target are generated: one with a content hash in the filename\nand one without. The hashed names are for applications that can dynamically\ndetect which files to serve, and the hashes serve to make the files indefinitely\ncacheable. The un-hashed names are for things that need predictable filenames,\nlike the static page outside your web stack that runs your JS tests.\n\nThe build generates two metadata files that give you information about the\ngenerated assets, to make it easy to generate links to them from your\napplication.\n\n`.wake.json` is generated in the root of the project and contains an index\ntelling you the absolute paths of the source files and target files for each\nasset in your configuration. For our example, this looks like:\n\n```js\n{\n  \"javascript\": {\n    \"scripts.js\": {\n      \"sources\": [\n        \"public/javascripts/foo.js\",\n        \"public/javascripts/bar.js\"\n      ],\n      \"targets\": {\n        \"min\": \"public/assets/scripts.js\"\n      }\n    }\n  },\n  \"css\": {\n    \"styles.css\": {\n      \"sources\": [\n        \"public/stylesheets/navigation.css\",\n        \"public/stylesheets/footer.css\"\n      ],\n      \"targets\": {\n        \"min\": \"public/assets/styles.css\"\n      }\n    }\n  },\n  \"binary\": {\n    \"logo.png\": {\n      \"sources\": [\n        \"public/images/logo.png\"\n      ],\n      \"targets\": {\n        \"min\": \"public/assets/logo.png\"\n      }\n    }\n  }\n}\n```\n\nThe second metadata file is `.manifest.json`. This file is generated in each\ndirectory that contains targets with content hashes in their filenames, and\ncontains a mapping from the canonical filename to the hashed one. This lets an\napplication find the hashed filename for each file it wants to link to.\n\n```js\n// public/assets/.manifest.json\n\n{\n  \"scripts.js\": \"scripts-bb210c6.js\",\n  \"scripts.js.map\": \"scripts-300b304.js.map\",\n  \"styles.css\": \"styles-5a2ceb1.css\",\n  \"logo.png\": \"logo-2fa8d38.png\"\n}\n```\n\n\n### Configuration short-hands\n\nIt can be cumbersome to list out every file in the project, especially for\nbinary files which just copy one file from one place to another. So, there are\ntwo shorthands you can use to make things easier.\n\n#### Blank targets\n\nIf you give the empty string in place of the source list for a target, `wake`\njust inserts the name of the target file as the name of the source. So, these\nare equivalent:\n\n```js\n      \"targets\": {                \"targets\": {\n        \"logo.png\": \"\"              \"logo.png\": [\"logo.png\"]\n      }                           }\n```\n\n#### Path globbing\n\nRather than list every file in the project, you can use a glob. For example,\nthis generates a target for every CSS file in `public/stylesheets` (but not its\nsubdirectories):\n\n```js\n    \"css\": {\n      \"sourceDirectory\": \"public/stylesheets\",\n      \"targetDirectory\": \"public/assets\",\n      \"targets\": {\n        \"*.css\": \"\"\n      }\n    }\n```\n\nAnd this generates a target for each file in `public/images` and all its\nsubdirectories:\n\n```js\n    \"binary\": {\n      \"sourceDirectory\": \"public/images\",\n      \"targetDirectory\": \"public/assets\",\n      \"targets\": {\n        \"**/*.*\": \"\"\n      }\n    }\n```\n\n\n### Customising the build\n\n`wake` comes with default behaviour that is optimised for application\ndevelopment, but it can be customised to provide additional information your app\nmight need, or to change how it builds files. Consider our original example\nJavaScript configuration:\n\n```js\n    \"javascript\": {\n      \"sourceDirectory\": \"public/javascripts\",\n      \"targetDirectory\": \"public/assets\",\n      \"targets\": {\n        \"scripts.js\": [\"foo.js\", \"bar.js\"]\n      }\n    }\n```\n\nThe source files are converted into the target files using a set of *build\nsettings*. You can specify multiple builds with different settings. For example,\nthis configuration generates a minified and unminified copy of the build with no\ncontent hash, which is more suitable for library development:\n\n```js\n    \"javascript\": {\n      \"sourceDirectory\": \"public/javascripts\",\n      \"targetDirectory\": \"public/assets\",\n      \"builds\": {\n        \"src\": {\"digest\": false, \"minify\": false},\n        \"min\": {\"digest\": false, \"minify\": true, \"tag\": \"suffix\", \"sourceMap\": \"src\"}\n      },\n      \"targets\": {\n        \"scripts.js\": [\"foo.js\", \"bar.js\"]\n      }\n    }\n```\n\nThis generates three files: `scripts.js`, `scripts-min.js` and\n`scripts-min.js.map`, where the source map references `scripts.js` instead of\n`foo.js` and `bar.js`.\n\nBy default, `wake` generates build settings for each group with a build called\n`min` that's optimised for application development. If you specify your own\nsettings, these are the options you can set:\n\n#### All asset types\n\n* `digest` - set to `false` if you don't want content hashes in generated\n  filenames\n* `tag` - specifies where to put the build name in the generated filenames.\n  * `prefix` puts the build name at the start of the filename, e.g.\n    `min-scripts.js`\n  * `suffix` puts the build name the end of the filename, e.g. `scripts-min.js`\n  * `directory` puts the file inside a directory named for the build, e.g.\n    `min/scripts.js`\n\n#### JavaScript assets\n\n* `minify` - set to `false` if you only want the files to be concatenated, not\n  minified\n* `safe` - set to `true` if you want the minifier to avoid potentially unsafe\n  optimisations\n* `separator` - sets the string inserted between files during concatenation, the\n  default is two line feed characters\n* `sourceMap` - set to `false` if you don't want a source map to be generated,\n  set it to the name of a build (as above) if you want the map to reference that\n  build as the source rather than the original source files\n\n#### CSS assets\n\n* `inline` - set to `true` if you want images, fonts and other files referenced\n  by `url()` expressions to be inlined as data URIs\n* `minify` - set to `false` if you only want the files to be concatenated, not\n  minified\n* `safe` - set to `true` if you want the minifier to avoid potentially unsafe\n  optimisations\n* `separator` - sets the string inserted between files during concatenation, the\n  default is two line feed characters\n\n\n### CSS asset hosts\n\nIf you're using multiple hostnames to serve assets from, you'll want to insert\nthese hostnames into the optimised CSS. You might have different hostnames for\nHTTPS vs HTTP pages. To make `wake` add asset hosts to `url()` expressions, you\nneed to specifiy a few things in your `css` group config:\n\n* `targetRoot` - this is the document root of the server that provides your\n  static assets, it will often be the same as `sourceRoot`\n* `hosts` - this is an index of all your asset hosts, indexed by environment and\n  type\n* `builds` - each build must say which type of host it should use, if any\n\nHere's an example. We have two sets of asset hosts, one called `http` and one\ncalled `https`. Each environment we deploy our app to has a different list of\nhostnames for each set. The `hosts` setting below lists the hosts for each set\nfor the `production` and `staging` environments.\n\n```js\n    \"css\": {\n      \"sourceDirectory\": \"public/stylesheets\",\n      \"targetDirectory\": \"public/assets\",\n      \"sourceRoot\":      \"public\",\n      \"targetRoot\":      \"public\",\n      \"hosts\": {\n        \"production\": {\n          \"http\":  [\"http://static1.example.com\", \"http://static2.example.com\"],\n          \"https\": [\"https://ssl1.example.com\", \"https://ssl2.example.com\"]\n        },\n        \"staging\": {\n          \"http\":  [\"http://static1.staging.example.net\", \"http://static2.staging.example.net\"],\n          \"https\": [\"https://ssl1.staging.example.net\", \"https://ssl2.staging.example.net\"]\n        }\n      },\n      \"builds\": {\n        \"min\": {\"hosts\": \"http\"},\n        \"ssl\": {\"hosts\": \"https\", \"tag\": \"suffix\"}\n      },\n      \"targets\": {\n        \"styles.css\": [\"navigation.css\", \"footer.css\"]\n      }\n    }\n```\n\nThe two `builds` here will generate two files: `styles.css` will use the `http`\nset of hosts, and `styles-ssl.css` will use the `https` set. Which exact list of\nhosts you get depends on the environment, which you specify on the command line:\n\n```\n$ WAKE_ENV=production wake\n```\n\nIf you don't specify an environment, `wake` will use the host sets under\n`hosts.default`, if you have specified a default set.\n\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2013 James Coglan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the 'Software'), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n",
  "readmeFilename": "README.md",
  "_id": "wake@0.3.0",
  "_from": "wake@~0.3.0"
}
